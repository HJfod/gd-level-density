<!DOCTYPE html>
<html>
    <head>
        <title>Level density</title>
        <meta charset="utf-8">
        <style>
            body {
                font-family: Segoe UI;
            }

            canvas {
                background-color: #aaa;
            }

            canvas:hover {
                cursor: nw-resize;
            }
        </style>
    </head>

    <body>
        <button onclick="select()">Select level</button>
        <br>
        <text id="info"></text>
        <br><br>
        <canvas id="level-density" width=1200 height=300></canvas>
        <br>
        <text id="level-info"></text>
    </body>

    <script>
        const ipc = require("electron").ipcRenderer;
        const canvas = document.getElementById("level-density");
        const ctx = canvas.getContext("2d");

        let timeStamp;
        let resizing = false;

        const accuracy = { x: 100, y: 50 };

        canvas.addEventListener("mousedown", e => resizing = { x: e.offsetX, y: e.offsetY, w: canvas.width, h: canvas.height });
        document.addEventListener("mouseup", e => resizing = false);
        document.addEventListener("mousemove", e => {
            if (resizing) {
                canvas.width = resizing.w + e.offsetX - resizing.x;
                canvas.height = resizing.h + e.offsetY - resizing.y;
            }
        })

        function select() {
            timeStamp = performance.now();
            ipc.send("main", JSON.stringify({ action: "level-path" }));
        }

        function drawData(points, y) {
            ctx.clearRect(0,0,canvas.width, canvas.height);

            ctx.translate(0, canvas.height);
            ctx.scale(1, -1);

            const nearest = points[0].x;
            const furthest = points[points.length-1].x;
            const highest = y[y.length-1];
            const lowest = y[0];

            const chunks = Array.from({ length: accuracy.x }, () => 
                Array.from({ length: accuracy.y }, () => false)
            );

            points.forEach(p => {
                let cx = Math.round( ((p.x - nearest) / furthest * canvas.width) / (canvas.width / ( accuracy.x - 1 )) );
                let cy = Math.round( ((p.y - lowest)  / highest * canvas.height) / (canvas.height / ( accuracy.y - 1 )) );
                
                if (cx < 0) cx = 0;
                if (cy < 0) cy = 0;
                let c = chunks[cx][cy];
                c ? c += 1 : c = 1;
                chunks[cx][cy] = c;
            });

            let most = 0, least = 0, base = .1;
            chunks.forEach(c => {
                c.forEach(a => {
                    if (a > most) {
                        most = a;
                    }else if (a < least) {
                        least = a;
                    }
                });
            });

            let w = (canvas.width / accuracy.x),
                h = (canvas.height / accuracy.y);
            ctx.fillStyle = "#f00";
            chunks.forEach((c, x) => {
                c.forEach((a, y) => {
                    ctx.globalAlpha = a / most;
                    ctx.fillRect(x * w, y * h, w, h );
                });
            });

            document.getElementById("level-info").innerHTML = `Operation took ${Math.round(performance.now()-timeStamp)} ms.<br>
            Chunks: ${accuracy.x}x${accuracy.y}<br>
            Most objects in a chunk: ${most}<br>
            Least objects in a chunk: ${least}<br>
            Total objects: ${points.length}`;
        }

        ipc.on("main", (event, arg) => {
            const args = JSON.parse(arg);

            switch (args.action) {
                case "info":
                    document.getElementById("info").innerHTML = args.info;
                    break;
                case "level-data":
                    let points = [];
                    let y = args.y.map(o => Number(o));
                    args.x.map(o => Number(o)).forEach((i, ix) => {
                        points.push({ x: i, y: y[ix] });
                    });
                    sortedByY = y.sort((a, b) => a - b);
                    
                    drawData(points, sortedByY);
                    break;
            }
        });

    </script>
</html>